global proc shelf_JukovCG_scripts () {
    global string $gBuffStr;
    global string $gBuffStr0;
    global string $gBuffStr1;


    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "CurvesFromTubes" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "CurvesFromTubes" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "CFT" 
        -overlayLabelColor 1 1 0 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "curveAddPt.png" 
        -image1 "curveAddPt.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "'CurveFromTubes'\n\nimport time\nimport maya.api.OpenMaya as Newom\nfrom pymel.core import *\nimport itertools\nfrom functools import partial\nimport maya.OpenMayaUI as apiUI\n\nvers = '2017-2019'\nif int(str(versions.current())[0:4]) == 2020:\n\tvers = 2020\n\ntry:\n\tfrom PySide2.QtCore import * \n\tfrom PySide2.QtGui import * \n\tfrom PySide2.QtWidgets import *\n\tfrom PySide2 import __version__\n\tfrom shiboken2 import wrapInstance \nexcept ImportError:\n\tfrom PySide.QtCore import * \n\tfrom PySide.QtGui import * \n\tfrom PySide import __version__\n\tfrom shiboken import wrapInstance\n\ndef getMayaWindow():\n\tptr = apiUI.MQtUtil.mainWindow()\n\tif ptr is not None:\n\t\treturn wrapInstance(long(ptr), QWidget)\n\n\nclass AboutWindow (QWidget):\n\tdef __init__(self, parent = None):\n\t\tsuper(AboutWindow, self).__init__(parent)\n\t\thPanel = 30\n\t\tself.xAw = parent.sizeHint().width()\n\t\tself.yAw = parent.sizeHint().height()\n\t\tself.setWindowFlags(Qt.Window)\n\t\tself.setWindowTitle('About')\n\t\tself.mainMenuRect = parent.geometry()\n\t\tself.move(self.mainMenuRect.center() + QPoint((self.xAw)/2, -(self.yAw/2 + hPanel)))\n\t\tself.textBrowser = QTextBrowser(self)\n\t\tself.textBrowser.setGeometry(QRect(10, 10, self.xAw - 20, self.yAw - 20))\n\t\tself.textBrowser.setObjectName(\"textBrowser\")\n\t\tself.textBrowser.setText(\"Script by Jukov.CG \\nJukov.CG@gmail.com \\nArtStation:\\nhttps://www.artstation.com/jukovcg\")\n\t\t\n\t\tself.verticalLayoutAw = QVBoxLayout(self)\n\t\t\n\t\tself.verticalLayoutAw.addWidget(self.textBrowser)\n\tdef sizeHint(self):\n\t\treturn QSize(self.xAw, self.yAw)\n\nclass CurveFromTubes(QWidget):\n\tdef __init__(self, parent = None):\n\t\tsuper(CurveFromTubes, self).__init__(parent)\n\t\t#[star3, star5, border, star2]\n\t\tself.maps = [[8,0,0,0],[0,2,0,0],[4,1,0,0],[4,0,1,0],[0,1,1,0],[0,0,1,0], [4,0,0,0], [0,0,0,0],[0,0,1,4]]\n\t\tself.x = 200\n\t\tself.y = 250\n\t\t\n\t\tself.setWindowFlags(Qt.Window)\n\t\tself.setWindowTitle('CFT')\n\t\tself.maya_win_rect = parent.geometry()\n\t\tself.move(self.maya_win_rect.center() + QPoint(0, 0))\n\t\t\n\t\tself.createCurves_btn = QPushButton('Create curves', self)\n\t\tself.createCurves_btn.clicked.connect(partial(self.createCurvesFromTubes, 'default'))\n\t\t\n\t\tself.groupBox = QGroupBox('Preference:', self)\n\t\t\n\t\tself.preference_grd = QGridLayout(self.groupBox)\n\t\t\n\t\tself.thresholdCurvePoints = QLabel(self.groupBox)\n\t\tself.thresholdCurvePoints.setText(\"Threshold for CV:\t\")\n\t\t\n\t\tself.thresholdCurvePointsVal = QLineEdit(self.groupBox)\n\t\tself.thresholdCurvePointsVal.setText('0.01')\n\t\t\n\t\tself.reverseCurve_chb = QCheckBox (self.groupBox)\n\t\tself.reverseCurve_chb.setText('Reverse curve:')\n\t\tself.reverseCurve_chb.setChecked(False)\n\t\t\n\t\t#----------------------------------------\n\t\t\n\t\tself.createCurvesWithWire_btn = QPushButton('Create curves + wire', self)\n\t\tself.createCurvesWithWire_btn.clicked.connect(partial(self.createCurvesFromTubes, 'wire'))\n\t\t\n\t\tself.wirePreference_grBox = QGroupBox('Wire Preference:', self)\n\t\t\n\t\tself.wirePreference_grd = QGridLayout(self.wirePreference_grBox)\n\t\t\n\t\tself.distanceLabel = QLabel(self)\n\t\tself.distanceLabel.setText(\"Dropoff Distance:\t\")\n\t\t\n\t\tself.distanceVal = QLineEdit(self)\n\t\tself.distanceVal.setText('50')\n\t\t\n\t\t#-------------------------------------------\n\t\t\n\t\tself.createCurvesWithJoints_btn = QPushButton('Create curves + joints', self)\n\t\tself.createCurvesWithJoints_btn.clicked.connect(partial(self.createCurvesFromTubes, 'joints'))\n\t\t\n\t\tself.jointPreference_grBox = QGroupBox('Joints Preference:', self)\n\t\t\n\t\tself.jointPreference_grd = QGridLayout(self.jointPreference_grBox)\n\t\t\n\t\tself.amountJoint_chb = QCheckBox (self.jointPreference_grBox)\n\t\tself.amountJoint_chb.setText('Joint number:')\n\t\tself.amountJoint_chb.setChecked(True)\n\t\tself.amountJoint_chb.clicked.connect(self.stepJoint_chanched)\n\t\t\n\t\tself.stepJoint_chb = QCheckBox (self.jointPreference_grBox)\n\t\tself.stepJoint_chb.setText('Joint step:')\n\t\tself.stepJoint_chb.clicked.connect(self.amountJoint_chanched)\n\t\t\n\t\tself.amountJoint_val = QLineEdit(self.jointPreference_grBox)\n\t\tself.amountJoint_val.setText('10')\n\t\t\n\t\tself.stepJoint_val = QLineEdit(self.jointPreference_grBox)\n\t\tself.stepJoint_val.setText('5')\n\t\t\n\t\tself.jointOrient_lbl = QLabel(self.jointPreference_grBox)\n\t\tself.jointOrient_lbl.setText(\"Orient joint:\")\n\t\t\n\t\tself.jointOrient_cBox = QComboBox(self.jointPreference_grBox)\n\t\tself.jointOrient_cBox.addItem('zyx')\n\t\tself.jointOrient_cBox.addItem('xyz')\n\t\tself.jointOrient_cBox.addItem('yzx')\n\t\tself.jointOrient_cBox.addItem('zxy')\n\t\tself.jointOrient_cBox.addItem('yxz')\n\t\tself.jointOrient_cBox.addItem('xzy')\n\t\tself.jointOrient_cBox.addItem('none')\n\t\t\n\t\tself.secondaryAxisOrient_lbl = QLabel(self.jointPreference_grBox)\n\t\tself.secondaryAxisOrient_lbl.setText(\"Secondary axis orient:\")\n\t\t\n\t\tself.secondaryAxisOrient_cBox = QComboBox(self.jointPreference_grBox)\n\t\tself.secondaryAxisOrient_cBox.addItem('yup')\n\t\tself.secondaryAxisOrient_cBox.addItem('xup')\n\t\tself.secondaryAxisOrient_cBox.addItem('xdown')\n\t\tself.secondaryAxisOrient_cBox.addItem('ydown')\n\t\tself.secondaryAxisOrient_cBox.addItem('zup')\n\t\tself.secondaryAxisOrient_cBox.addItem('zdown')\n\t\tself.secondaryAxisOrient_cBox.addItem('none')\n\t\t\n\t\t#-----------------------------------------------------\n\t\t\n\t\tself.deleteTrash_btn = QPushButton('Delete trash', self)\n\t\tself.deleteTrash_btn.clicked.connect(self.deleteTrash)\n\t\t\n\t\tself.aboutScript_btn = QPushButton('About', self)\n\t\tself.aboutScript_btn.clicked.connect(self.aboutScript)\n\t\t\n\n\t\tself.horizontalLayout = QHBoxLayout(self)\n\t\tself.verticalLayout = QVBoxLayout(self)\n\t\t\n\t\t\n\t\tself.verticalLayout.addWidget(self.createCurves_btn)\n\t\tself.verticalLayout.addWidget(self.groupBox)\n\t\tself.preference_grd.addWidget(self.thresholdCurvePoints, 0,0)\n\t\tself.preference_grd.addWidget(self.thresholdCurvePointsVal, 0,1)\n\t\tself.preference_grd.addWidget(self.reverseCurve_chb, 1,0)\n\t\t\n\t\tself.verticalLayout.addWidget(self.createCurvesWithWire_btn)\n\t\tself.verticalLayout.addWidget(self.wirePreference_grBox)\n\t\tself.wirePreference_grd.addWidget(self.distanceLabel, 0,0)\n\t\tself.wirePreference_grd.addWidget(self.distanceVal, 0,1)\n\t\t\n\t\tself.verticalLayout.addWidget(self.createCurvesWithJoints_btn)\n\t\tself.verticalLayout.addWidget(self.jointPreference_grBox)\n\t\tself.jointPreference_grd.addWidget(self.amountJoint_chb, 0,0)\n\t\tself.jointPreference_grd.addWidget(self.stepJoint_chb, 1,0)\n\t\tself.jointPreference_grd.addWidget(self.amountJoint_val, 0,1)\n\t\tself.jointPreference_grd.addWidget(self.stepJoint_val, 1,1)\n\t\tself.jointPreference_grd.addWidget(self.jointOrient_lbl, 2,0)\n\t\tself.jointPreference_grd.addWidget(self.jointOrient_cBox, 2,1)\n\t\tself.jointPreference_grd.addWidget(self.secondaryAxisOrient_lbl, 3,0)\n\t\tself.jointPreference_grd.addWidget(self.secondaryAxisOrient_cBox, 3,1)\n\t\t\n\n\t\t\n\t\tself.verticalLayout.addWidget(self.deleteTrash_btn)\n\t\tself.verticalLayout.addWidget(self.aboutScript_btn)\n\t\tself.horizontalLayout.addLayout(self.verticalLayout)\n\t\t\n\tdef sizeHint(self):\n\t\treturn QSize(self.x, self.y)\n\t\t\n\tdef stepJoint_chanched(self):\n\t\tself.stepJoint_chb.setChecked(False)\n\t\tself.amountJoint_chb.setChecked(True)\n\t\t\n\tdef amountJoint_chanched(self):\n\t\tself.amountJoint_chb.setChecked(False)\n\t\tself.stepJoint_chb.setChecked(True)\n\t\t\n\tdef closeEvent(self, close):\n\t\ttry:\n\t\t\tself.aboutMenu.close()\n\t\texcept:\n\t\t\tpass\n\t\t\n\tdef aboutScript(self):\n\t\ttry:\n\t\t\tself.aboutMenu.close()\n\t\texcept:\n\t\t\tpass\n\t\tself.aboutMenu = AboutWindow(self)\n\t\tself.aboutMenu.show()\n\t\t\n\tdef deleteTrash (self):\n\t\tdeleteReady = 0\n\t\ttry:\n\t\t\tif self.forDelete or len(self.forDelete) != 0 :\n\t\t\t\tdeleteReady = 1\n\t\texcept:\n\t\t\tpass\n\t\tif deleteReady == 1:\n\t\t\tfor d in self.forDelete:\n\t\t\t\ttry:\n\t\t\t\t\tdelete(d)\n\t\t\t\texcept:\n\t\t\t\t\tcontinue\n\t\telse:\n\t\t\tprint ' Object to delete is not found!'\n\t\t\n\tdef createCurvesFromTubes(self, mode = 'default'):\n\t\tt = time.time()\n\t\tprint '\\n\\n'\n\t\t# Select tubes\n\t\tundoInfo (openChunk=1)\n\t\ttry:\n\t\t\tself.threshold = float(self.thresholdCurvePointsVal.text())\n\t\texcept:\n\t\t\tprint 'Incorrect input! Deafult values are used.'\n\t\t\tself.threshold = 0.01\n\t\tself.sel = ls (sl=1, o=1, tr=1, s=1)\n\t\tself.geometryFromSelect = []\n\t\tfor self.s in self.sel:\n\t\t\tif self.s.type() == 'transform':\n\t\t\t\tif self.s.getShape():\n\t\t\t\t\tif self.s.getShape().type() == 'mesh':\n\t\t\t\t\t\tself.geometryFromSelect.append(self.s)\n\t\t\t\t\t\tif len(self.s.getChildren()) > 1:\n\t\t\t\t\t\t\tself.MeshInGroup (self.s, self.geometryFromSelect)\n\t\t\t\t\telif self.s.getShape().type() == 'nurbsCurve':\n\t\t\t\t\t\tself.MeshInGroup (self.s, self.geometryFromSelect)\n\t\t\t\telif self.s.getShape() == None:\n\t\t\t\t\tself.MeshInGroup (self.s, self.geometryFromSelect)\n\t\t\telif self.s.type() == 'mesh':\n\t\t\t\tself.geometryFromSelect.append(self.s)\n\t\tself.geometryFromSelect = list(set(self.geometryFromSelect))\n\n\t\t# Create group for curves\n\t\tgr = group(empty=1, name = 'curvesFromTubes_grp')\n\t\tif mode == 'wire':\n\t\t\twireGr = group(empty=1, name = 'wireBase_grp')\n\t\tif mode == 'joints':\n\t\t\tjointsGr = group(empty=1, name = 'joints_grp')\n\t\tself.forDelete = []\n\t\tbadTopology = []\n\n\t\t# Start workikg with each tube\n\t\tfor g in self.geometryFromSelect:\n\t\t\t# Get info about tube (name, path, obj)\n\t\t\tdagPath = g.__apimdagpath__()\n\t\t\tobj = dagPath.node()\n\t\t\tfullName = dagPath.fullPathName()\n\t\t\tname = fullName.split('|')[-1]\n\t\t\t\n\t\t\t# Duplicate tube, rename, unparent\n\t\t\tdupl = duplicate(g, name = name + '_tube')[0]\n\t\t\tif dupl not in self.forDelete:\n\t\t\t\tself.forDelete.append(dupl)\n\t\t\tdupl.setParent(None)\n\n\t\t\t# Separate combine tubes\n\t\t\tshellsNum = polyEvaluate(g, shell=1)\n\t\t\tif shellsNum > 1 and mode == 'default':\n\t\t\t\ttry:\n\t\t\t\t\tshellsGlobal = polySeparate (dupl, ch=0)\n\t\t\t\texcept:\n\t\t\t\t\tif dupl not in self.forDelete:\n\t\t\t\t\t\tself.forDelete.append(dupl)\n\t\t\t\t\tcontinue\n\t\t\t\tx=1\n\t\t\t\tif len(shellsGlobal) < 10:\n\t\t\t\t\tfor shGl in shellsGlobal:\n\t\t\t\t\t\tshGl.rename(name +'_000'+ str(x) + '_tube')\n\t\t\t\t\t\tparent (shGl, w=1)\n\t\t\t\t\t\tx+=1\n\t\t\t\t\tif dupl not in self.forDelete:\n\t\t\t\t\t\tself.forDelete.append(dupl)\n\t\t\t\telif len(shellsGlobal) >= 10 and len(shellsGlobal)<100:\n\t\t\t\t\tfor shGl in shellsGlobal:\n\t\t\t\t\t\tshGl.rename(name +'_00'+ str(x) + '_tube')\n\t\t\t\t\t\tparent (shGl, w=1)\n\t\t\t\t\t\tx+=1\n\t\t\t\t\tif dupl not in self.forDelete:\n\t\t\t\t\t\tself.forDelete.append(dupl)\n\t\t\t\telif len(shellsGlobal) >= 100:\n\t\t\t\t\tfor shGl in shellsGlobal:\n\t\t\t\t\t\tshGl.rename(name +'_0'+ str(x) + '_tube')\n\t\t\t\t\t\tparent (shGl, w=1)\n\t\t\t\t\t\tx+=1\n\t\t\t\t\tif dupl not in self.forDelete:\n\t\t\t\t\t\tself.forDelete.append(dupl)\n\t\t\t\telif len(shellsGlobal) >= 1000:\n\t\t\t\t\tfor shGl in shellsGlobal:\n\t\t\t\t\t\tshGl.rename(name +'_'+ str(x) + '_tube')\n\t\t\t\t\t\tparent (shGl, w=1)\n\t\t\t\t\t\tx+=1\n\t\t\t\t\tif dupl not in self.forDelete:\n\t\t\t\t\t\tself.forDelete.append(dupl)\n\t\t\telif shellsNum == 1:\n\t\t\t\tshellsGlobal = [dupl,]\n\t\t\telif shellsNum > 1 and mode != 'default':\n\t\t\t\tshellsGlobal = []\n\t\t\tomShellsGlobal = Newom.MSelectionList()\n\t\t\tfor shGl in shellsGlobal:\n\t\t\t\tomShellsGlobal.add(shGl.fullPath())\n\t\t\tomShellsGlobalIt = Newom.MItSelectionList(omShellsGlobal)\n\t\t\twhile not omShellsGlobalIt.isDone():\n\t\t\t\tplane = 0\n\t\t\t\tself.shGlDagPath = omShellsGlobalIt.getDagPath()\n\t\t\t\tself.PyShGlObj = PyNode(self.shGlDagPath.fullPathName())\n\t\t\t\tif self.checkMesh(self.shGlDagPath) == 1:\n\t\t\t\t\tif g not in badTopology:\n\t\t\t\t\t\tbadTopology.append(g)\n\t\t\t\t\tself.forDelete.append(self.PyShGlObj)\n\t\t\t\telse:\n\t\t\t\t\t# Find stars and borders\n\t\t\t\t\tself.star5 = self.getVertexStars(self.shGlDagPath, 5)\n\t\t\t\t\tself.star3 = self.getVertexStars(self.shGlDagPath, 3)\n\t\t\t\t\tself.star2 = self.getVertexStars(self.shGlDagPath, 2, 'Border')\n\t\t\t\t\tself.border = self.getBorderEdges(self.shGlDagPath)\n\t\t\t\t\tif len(self.border)== 0:\n\t\t\t\t\t\tborderKey = 0\n\t\t\t\t\telse:\n\t\t\t\t\t\tborderKey = 1\n\t\t\t\t\tshells = []\n\t\t\t\t\tself.loopsForCut = []\n\t\t\t\t\tif [len(self.star3),len(self.star5),borderKey, len(self.star2)] in self.maps:\n\t\t\t\t\t\tif [len(self.star3),len(self.star5),borderKey, len(self.star2)] == [0,0,0,0]:\n\t\t\t\t\t\t\tself.vTorus = 0\n\t\t\t\t\t\t\tself.edgesTorus = self.ComponentInfo(self.vTorus, 'vtx', 'toEdge', self.shGlDagPath)\n\t\t\t\t\t\t\tself.loopsTorus = []\n\t\t\t\t\t\t\tfor self.edgeTorus in self.edgesTorus:\n\t\t\t\t\t\t\t\tself.loopTorus = []\n\t\t\t\t\t\t\t\tself.loopTorusVtx = []\n\t\t\t\t\t\t\t\tself.toEdgeLoop (self.edgeTorus, self.loopTorus, self.loopTorusVtx, self.shGlDagPath)\n\t\t\t\t\t\t\t\tself.loopsTorus.append(sorted(self.loopTorus))\n\t\t\t\t\t\t\tself.loopsTorus = self.DeleteReplayFromList(self.loopsTorus)\n\t\t\t\t\t\t\tif len(self.loopsTorus) == 2:\n\t\t\t\t\t\t\t\tself.L1 = round(self.ComponentInfo(self.loopsTorus[0], 'edge', 'length', self.shGlDagPath), 10)\n\t\t\t\t\t\t\t\tself.L2 = round(self.ComponentInfo(self.loopsTorus[1], 'edge', 'length', self.shGlDagPath), 10)\n\t\t\t\t\t\t\t\tif self.L1 == min(self.L1, self.L2):\n\t\t\t\t\t\t\t\t\tpolySplitEdge (map(lambda x: self.PyShGlObj.e[x], self.loopsTorus[0]))\n\t\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t\tpolySplitEdge (map(lambda x: self.PyShGlObj.e[x], self.loopsTorus[1]))\n\t\t\t\t\t\telif [len(self.star3),len(self.star5),borderKey, len(self.star2)] == [0,0,1,4]:\n\t\t\t\t\t\t\tplane = 1\n\t\t\t\t\t\tif self.star5:\n\t\t\t\t\t\t\tfor self.st5 in self.star5:\n\t\t\t\t\t\t\t\tself.loopVtx = self.ComponentInfo(self.st5, 'vtx','toVtx', self.shGlDagPath)\n\t\t\t\t\t\t\t\tself.loopEdge = self.ComponentInfo(self.loopVtx, 'vtx','toContainedEdges', self.shGlDagPath)\n\t\t\t\t\t\t\t\tself.loopsForCut.append(self.loopEdge)\n\t\t\t\t\t\tif self.star3:\n\t\t\t\t\t\t\tself.pathes = []\n\t\t\t\t\t\t\tfor self.st3 in self.star3:\n\t\t\t\t\t\t\t\tself.edgesSt3 = self.ComponentInfo(self.st3, 'vtx', 'toEdge', self.shGlDagPath)\n\t\t\t\t\t\t\t\tfor self.edSt3 in self.edgesSt3:\n\t\t\t\t\t\t\t\t\tself.loop = []\n\t\t\t\t\t\t\t\t\tself.loopVtx = []\n\t\t\t\t\t\t\t\t\tself.toEdgeLoop (self.edSt3, self.loop, self.loopVtx, self.shGlDagPath)\n\t\t\t\t\t\t\t\t\tif filter(lambda x: x in self.star3 and x!= self.st3, self.loopVtx):\n\t\t\t\t\t\t\t\t\t\tself.pathes.append(sorted (self.loop))\n\t\t\t\t\t\t\tself.pathes = self.DeleteReplayFromList(self.pathes)\n\t\t\t\t\t\t\tlengths = []\n\t\t\t\t\t\t\tdictLength = []\n\t\t\t\t\t\t\tfor self.path in self.pathes:\n\t\t\t\t\t\t\t\tlength = round(self.ComponentInfo(self.path, 'edge', 'length', self.shGlDagPath), 10)\n\t\t\t\t\t\t\t\tdL = str(length) + ':'\n\t\t\t\t\t\t\t\tfor p in self.path:\n\t\t\t\t\t\t\t\t\tdL = dL + str(p) +'|'\n\t\t\t\t\t\t\t\tlengths.append(length)\n\t\t\t\t\t\t\t\tdictLength.append(dL)\n\t\t\t\t\t\t\tself.capsLoops = []\n\t\t\t\t\t\t\tlengths = sorted(lengths)[:len(self.star3)]\n\t\t\t\t\t\t\tself.capsLoops = filter(lambda x: round(float(x.split(':')[0]), 10) in lengths, dictLength)\n\t\t\t\t\t\t\tself.capsLoops = map(lambda x: x.split(':')[-1].split('|')[:-1], self.capsLoops)\n\t\t\t\t\t\t\tself.capsLoops = map(lambda y: map(lambda x: int(x), y), self.capsLoops)\n\t\t\t\t\t\t\tself.loopsForCut.append(self.capsLoops)\n\t\t\t\t\t\ttubes = []\n\t\t\t\t\t\tif self.loopsForCut:\n\t\t\t\t\t\t\tself.loopsForCutPy = map(lambda x: self.PyShGlObj.e[x], list(itertools.chain(*self.loopsForCut)))\n\t\t\t\t\t\t\tpolySplitEdge (self.loopsForCutPy)\n\t\t\t\t\t\t\tnameTube = self.PyShGlObj.name().split('|')[-1] + '_shell'\n\t\t\t\t\t\t\ttubeShells = []\n\t\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\t\ttubeShells = polySeparate (self.PyShGlObj, ch=0)\n\t\t\t\t\t\t\texcept:\n\t\t\t\t\t\t\t\tif g not in badTopology:\n\t\t\t\t\t\t\t\t\tbadTopology.append(g)\n\t\t\t\t\t\t\t\tif self.PyShGlObj not in self.forDelete:\n\t\t\t\t\t\t\t\t\tself.forDelete.append(self.PyShGlObj)\n\t\t\t\t\t\t\tif tubeShells:\n\t\t\t\t\t\t\t\tfor tSh in tubeShells:\n\t\t\t\t\t\t\t\t\tparent(tSh, w=1)\n\t\t\t\t\t\t\t\t\ttShSelList = Newom.MSelectionList()\n\t\t\t\t\t\t\t\t\ttShSelList.add(tSh.fullPath())\n\t\t\t\t\t\t\t\t\tself.tShDagPath = tShSelList.getDagPath(0)\n\t\t\t\t\t\t\t\t\tif self.getVertexStars(self.tShDagPath, 5):\n\t\t\t\t\t\t\t\t\t\tif tSh not in self.forDelete:\n\t\t\t\t\t\t\t\t\t\t\tself.forDelete.append(tSh)\n\t\t\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t\t\telif self.getVertexStars(self.tShDagPath, 3, 'Border'):\n\t\t\t\t\t\t\t\t\t\tif tSh not in self.forDelete:\n\t\t\t\t\t\t\t\t\t\t\tself.forDelete.append(tSh)\n\t\t\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t\t\ttSh.rename(nameTube)\n\t\t\t\t\t\t\t\t\t\ttubes.append(tSh)\n\t\t\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t\tif self.PyShGlObj not in self.forDelete:\n\t\t\t\t\t\t\t\t\tself.forDelete.append(self.PyShGlObj)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\ttubes.append(self.PyShGlObj)\n\t\t\t\t\t\tif tubes:\n\t\t\t\t\t\t\tfor tube in tubes:\n\t\t\t\t\t\t\t\ttubeSelList = Newom.MSelectionList()\n\t\t\t\t\t\t\t\ttubeSelList.add(tube.fullPath())\n\t\t\t\t\t\t\t\tself.tubeDagPath = tubeSelList.getDagPath(0)\n\t\t\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\t\t\tif plane ==1:\n\t\t\t\t\t\t\t\t\t\tself.planeStartVtx = self.star2[0]\n\t\t\t\t\t\t\t\t\t\tself.planeStartEdges = self.ComponentInfo(self.planeStartVtx, 'vtx', 'toEdge', self.tubeDagPath)\n\t\t\t\t\t\t\t\t\t\tif len (self.planeStartEdges) == 2:\n\t\t\t\t\t\t\t\t\t\t\tself.start1 = []\n\t\t\t\t\t\t\t\t\t\t\tself.startVtx1 = []\n\t\t\t\t\t\t\t\t\t\t\tself.toEdgeLoop(self.planeStartEdges[0], self.start1, self.startVtx1, self.tubeDagPath)\n\t\t\t\t\t\t\t\t\t\t\tself.start2 = []\n\t\t\t\t\t\t\t\t\t\t\tself.startVtx2 = []\n\t\t\t\t\t\t\t\t\t\t\tself.toEdgeLoop(self.planeStartEdges[1], self.start2, self.startVtx2, self.tubeDagPath)\n\t\t\t\t\t\t\t\t\t\t\tself.planeL1 = round(self.ComponentInfo(self.start1, 'edge', 'length', self.tubeDagPath), 10)\n\t\t\t\t\t\t\t\t\t\t\tself.planeL2 = round(self.ComponentInfo(self.start2, 'edge', 'length', self.tubeDagPath), 10)\n\t\t\t\t\t\t\t\t\t\t\tif self.planeL1 == min(self.planeL1, self.planeL2):\n\t\t\t\t\t\t\t\t\t\t\t\tself.start = self.start1\n\t\t\t\t\t\t\t\t\t\t\t\tself.startVtx = self.startVtx1\n\t\t\t\t\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t\t\t\t\tself.start = self.start2\n\t\t\t\t\t\t\t\t\t\t\t\tself.startVtx = self.startVtx2\n\t\t\t\t\t\t\t\t\t\t\tself.planeEndVtx = filter(lambda x: x not in self.startVtx ,self.star2)[0]\n\t\t\t\t\t\t\t\t\t\t\tself.planeEndEdges = self.ComponentInfo(self.planeEndVtx, 'vtx', 'toEdge', self.tubeDagPath)\n\t\t\t\t\t\t\t\t\t\t\tif len (self.planeEndEdges) == 2:\n\t\t\t\t\t\t\t\t\t\t\t\tself.end1 = []\n\t\t\t\t\t\t\t\t\t\t\t\tself.endVtx1 = []\n\t\t\t\t\t\t\t\t\t\t\t\tself.toEdgeLoop(self.planeEndEdges[0], self.end1, self.endVtx1, self.tubeDagPath)\n\t\t\t\t\t\t\t\t\t\t\t\tself.end2 = []\n\t\t\t\t\t\t\t\t\t\t\t\tself.endVtx2 = []\n\t\t\t\t\t\t\t\t\t\t\t\tself.toEdgeLoop(self.planeEndEdges[1], self.end2, self.endVtx2, self.tubeDagPath)\n\t\t\t\t\t\t\t\t\t\t\t\tself.planeEndL1 = round(self.ComponentInfo(self.end1, 'edge', 'length', self.tubeDagPath), 10)\n\t\t\t\t\t\t\t\t\t\t\t\tself.planeEndL2 = round(self.ComponentInfo(self.end2, 'edge', 'length', self.tubeDagPath), 10)\n\t\t\t\t\t\t\t\t\t\t\t\tif self.planeEndL1 == min(self.planeEndL1, self.planeEndL2):\n\t\t\t\t\t\t\t\t\t\t\t\t\tself.end = self.end1\n\t\t\t\t\t\t\t\t\t\t\t\t\tself.endVtx = self.endVtx1\n\t\t\t\t\t\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t\t\t\t\t\tself.end = self.end2\n\t\t\t\t\t\t\t\t\t\t\t\t\tself.endVtx = self.endVtx2\n\t\t\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t\t\tself.borderEdges = self.getBorderEdges(self.tubeDagPath)\n\t\t\t\t\t\t\t\t\t\tself.start = []\n\t\t\t\t\t\t\t\t\t\tself.startVtx = []\n\t\t\t\t\t\t\t\t\t\tself.toEdgeLoop(self.borderEdges[0], self.start, self.startVtx, self.tubeDagPath)\n\t\t\t\t\t\t\t\t\t\tself.end = filter (lambda i: i not in self.start, self.borderEdges)\n\t\t\t\t\t\t\t\t\tself.rings = [self.start, ]\n\t\t\t\t\t\t\t\t\tself.face_done = []\n\t\t\t\t\t\t\t\t\tself.RingByRing (self.start, self.end, self.rings, self.face_done, self.tubeDagPath)\n\t\t\t\t\t\t\t\t\tcenters = []\n\t\t\t\t\t\t\t\t\tfor self.ring in self.rings:\n\t\t\t\t\t\t\t\t\t\tcenter = self.CentralPosition (self.ring, 'edge' , self.tubeDagPath)\n\t\t\t\t\t\t\t\t\t\tcenters.append (center[:3])\n\t\t\t\t\t\t\t\t\tnameCurv = tube.name().split('|')[-1].split('_tube')[0] + '_crv'\n\t\t\t\t\t\t\t\t\tself.forDelete.append(tube)\n\t\t\t\t\t\t\t\t\tif len(centers) > 3: \n\t\t\t\t\t\t\t\t\t\tcurv = curve (p=centers, ws=1, n = nameCurv)\n\t\t\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t\t\tcurv = curve (p=centers, ws=1, n = nameCurv, d=1)\n\t\t\t\t\t\t\t\t\tif self.reverseCurve_chb.isChecked():\n\t\t\t\t\t\t\t\t\t\tcurv.reverse()\n\t\t\t\t\t\t\t\t\tcurveSelList = Newom.MSelectionList()\n\t\t\t\t\t\t\t\t\tcurveSelList.add(curv.fullPath())\n\t\t\t\t\t\t\t\t\tcurveDagPath = curveSelList.getDagPath(0)\n\t\t\t\t\t\t\t\t\tcurveFn = Newom.MFnNurbsCurve(curveDagPath)\n\t\t\t\t\t\t\t\t\tbadPoints = []\n\t\t\t\t\t\t\t\t\tfor prevPoint in xrange(curveFn.numCVs-1):\n\t\t\t\t\t\t\t\t\t\tprevPointPos = curveFn.cvPosition(prevPoint, Newom.MSpace.kWorld)\n\t\t\t\t\t\t\t\t\t\tcurrPointPos = curveFn.cvPosition(prevPoint+1, Newom.MSpace.kWorld)\n\t\t\t\t\t\t\t\t\t\tvect = Newom.MVector (currPointPos - prevPointPos)\n\t\t\t\t\t\t\t\t\t\tif vect.length() < self.threshold:\n\t\t\t\t\t\t\t\t\t\t\tbadPoints.append(prevPoint+1)\n\t\t\t\t\t\t\t\t\tbadPoints = map(lambda x: curv.cv[x],badPoints)\n\t\t\t\t\t\t\t\t\tdelete(badPoints)\n\t\t\t\t\t\t\t\t\tif curveFn.length() > self.threshold:\n\t\t\t\t\t\t\t\t\t\tcurv.setRotatePivot(curv.getCV(0,space = 'world'))\n\t\t\t\t\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\t\t\t\t\tif mode == 'wire':\n\t\t\t\t\t\t\t\t\t\t\t\tcurv.rename(nameCurv + str(int(time.time())))\n\t\t\t\t\t\t\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\t\t\t\t\t\t\tself.dropoffDistanceWire = float(self.distanceVal.text())\n\t\t\t\t\t\t\t\t\t\t\t\texcept:\n\t\t\t\t\t\t\t\t\t\t\t\t\tprint 'Incorrect input! Deafult values are used.'\n\t\t\t\t\t\t\t\t\t\t\t\t\tself.dropoffDistanceWire = 50\n\t\t\t\t\t\t\t\t\t\t\t\twireForCurve = wire (g, w = curv)[0]\n\t\t\t\t\t\t\t\t\t\t\t\twire(wireForCurve, edit=1, dds = (0,self.dropoffDistanceWire))\n\t\t\t\t\t\t\t\t\t\t\t\twireBase = listConnections (wireForCurve.attr('baseWire[0]'))[0]\n\t\t\t\t\t\t\t\t\t\t\t\tparent (wireBase, wireGr)\n\t\t\t\t\t\t\t\t\t\t\t\tcurv.rename(nameCurv)\n\t\t\t\t\t\t\t\t\t\t\t\twireBase.rename(nameCurv + 'BaseWire')\n\t\t\t\t\t\t\t\t\t\texcept:\n\t\t\t\t\t\t\t\t\t\t\tpass\n\t\t\t\t\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\t\t\t\t\tif mode == 'joints':\n\t\t\t\t\t\t\t\t\t\t\t\tnumEP = curv.numEPs()\n\t\t\t\t\t\t\t\t\t\t\t\tself.duplCurv = duplicate(curv, n = nameCurv + '_dupl')[0]\n\t\t\t\t\t\t\t\t\t\t\t\tif self.amountJoint_chb.isChecked():\n\t\t\t\t\t\t\t\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnumberJoint = int(self.amountJoint_val.text())\n\t\t\t\t\t\t\t\t\t\t\t\t\texcept:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tprint 'Incorrect input! Deafult values are used.'\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnumberJoint = 15\n\t\t\t\t\t\t\t\t\t\t\t\telif self.stepJoint_chb.isChecked():\n\t\t\t\t\t\t\t\t\t\t\t\t\tlengthCurv = self.duplCurv.length()\n\t\t\t\t\t\t\t\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tstep = float(self.stepJoint_val.text())\n\t\t\t\t\t\t\t\t\t\t\t\t\texcept:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tprint 'Incorrect input! Deafult values are used.'\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tstep = 3\n\t\t\t\t\t\t\t\t\t\t\t\t\tif lengthCurv <= step:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnumberJoint = 1\n\t\t\t\t\t\t\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnumberJoint = int(lengthCurv/step)\n\t\t\t\t\t\t\t\t\t\t\t\tk = float(numEP)/float(numberJoint)\n\t\t\t\t\t\t\t\t\t\t\t\tif k < 2:\n\t\t\t\t\t\t\t\t\t\t\t\t\tk=1\n\t\t\t\t\t\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t\t\t\t\t\tk = int(k)\n\t\t\t\t\t\t\t\t\t\t\t\trebuildCurve(self.duplCurv, ch=False, rpo=True, rt=False, end=True, kr=False, kcp=False, kep=True, kt=True, s = numberJoint * k, d=3, tol=0.01)\n\t\t\t\t\t\t\t\t\t\t\t\tselect(cl=1)\n\t\t\t\t\t\t\t\t\t\t\t\tjoints = []\n\t\t\t\t\t\t\t\t\t\t\t\tj=1\n\t\t\t\t\t\t\t\t\t\t\t\tfor i in range(0,numberJoint*k+1, k):\n\t\t\t\t\t\t\t\t\t\t\t\t\tpoint = pointPosition (self.duplCurv.ep[i], w=1)\n\t\t\t\t\t\t\t\t\t\t\t\t\tjnt = joint (p = point, name = name + '_' + str(j) + '_jnt')\n\t\t\t\t\t\t\t\t\t\t\t\t\tjoints.append(jnt)\n\t\t\t\t\t\t\t\t\t\t\t\t\tj+=1\n\t\t\t\t\t\t\t\t\t\t\t\tparent(joints[0], jointsGr)\n\t\t\t\t\t\t\t\t\t\t\t\torientJ = self.jointOrient_cBox.currentText()\n\t\t\t\t\t\t\t\t\t\t\t\tsecAxis = self.secondaryAxisOrient_cBox.currentText()\n\t\t\t\t\t\t\t\t\t\t\t\tjoint (joints[0], e=1, oj = orientJ, secondaryAxisOrient = secAxis, ch=1, zso=1)\n\t\t\t\t\t\t\t\t\t\t\t\tjoint (joints[-1], e=1, oj = 'none', ch=1, zso=1)\n\t\t\t\t\t\t\t\t\t\t\t\tself.forDelete.append(self.duplCurv)\n\t\t\t\t\t\t\t\t\t\texcept:\n\t\t\t\t\t\t\t\t\t\t\tpass\n\t\t\t\t\t\t\t\t\t\tparent (curv, gr)\n\t\t\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t\t\tif g not in badTopology:\n\t\t\t\t\t\t\t\t\t\t\tbadTopology.append(g)\n\t\t\t\t\t\t\t\t\t\tself.forDelete.append(curv)\n\t\t\t\t\t\t\t\texcept:\n\t\t\t\t\t\t\t\t\tif g not in badTopology:\n\t\t\t\t\t\t\t\t\t\tbadTopology.append(g)\n\t\t\t\t\t\t\t\t\tself.forDelete.append(tube)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tif g not in badTopology:\n\t\t\t\t\t\t\t\tbadTopology.append(g)\n\t\t\t\t\t\t\tself.forDelete.append(self.PyShGlObj)\n\t\t\t\t\telse:\n\t\t\t\t\t\tif g not in badTopology:\n\t\t\t\t\t\t\tbadTopology.append(g)\n\t\t\t\t\t\tif self.PyShGlObj not in self.forDelete:\n\t\t\t\t\t\t\tself.forDelete.append(self.PyShGlObj)\n\t\t\t\tomShellsGlobalIt.next()\n\t\tdelete(self.forDelete)\n\t\tif badTopology:\n\t\t\tprint '      Contains bad topology for script:'\n\t\t\tfor bT in badTopology:\n\t\t\t\tprint bT\n\t\tif gr.getChildren():\n\t\t\tselect(gr)\n\t\telse:\n\t\t\tprint 'Proper geometry not found!'\n\t\t\tdelete(gr)\n\t\t\tif mode == 'wire':\n\t\t\t\tdelete(wireGr)\n\t\t\telif mode == 'joints':\n\t\t\t\tdelete(jointsGr)\n\t\tself.forDelete = []\n\t\tundoInfo (closeChunk=1)\n\t\tprint 'Script runtime: ' + str(time.time() - t)\n\n\tdef toEdgeLoop(self, index, result, vtxLoop, obj):\n\t\tindexError = 'Error: Incorrect input ID component!!!'\n\t\tobjError = 'Error: Incorrect input obj!!!'\n\t\tobjGood = 0\n\t\ttry:\n\t\t\ttry:\n\t\t\t\tindex = list(set(index))\n\t\t\texcept TypeError:\n\t\t\t\tindex = [index,]\n\t\texcept:\n\t\t\treturn indexError\n\t\t\t\n\t\ttry:\n\t\t\tif obj.apiType() == 110 or obj.apiType() == 296:\n\t\t\t\tobjGood = 1\n\t\texcept:\n\t\t\treturn objError\n\t\tif objGood == 1:\n\t\t\tfor self.i in index:\n\t\t\t\tif self.i not in result:\n\t\t\t\t\tresult.append(self.i)\n\t\t\t\t\tself.faces = self.ComponentInfo(self.i,'edge', 'toFace', obj)\n\t\t\t\t\tedges = self.ComponentInfo(self.faces,'face', 'toEdge', obj)\n\t\t\t\t\tself.vtx = self.ComponentInfo(self.i,'edge', 'toVtx', obj)\n\t\t\t\t\tfor self.v in self.vtx:\n\t\t\t\t\t\tif self.v not in vtxLoop:\n\t\t\t\t\t\t\tvtxLoop.append(self.v)\n\t\t\t\t\t\t\tself.edgesVtx = filter(lambda x: x not in edges, self.ComponentInfo(self.v, 'vtx', 'toEdge', obj))\n\t\t\t\t\t\t\tif len(self.edgesVtx) == 1:\n\t\t\t\t\t\t\t\tself.toEdgeLoop(self.edgesVtx[0], result, vtxLoop, obj)\n\n\tdef RingByRing (self, start, end, rings, face_done, obj):\n\t\tstartVtx = self.ComponentInfo(start, 'edge', 'toVtx', obj)\n\t\tstartFaceAll = self.ComponentInfo(start, 'edge', 'toFace', obj)\n\t\tself.startFace = filter (lambda i: i not in face_done, startFaceAll)\n\t\tvtx = self.ComponentInfo(self.startFace, 'face', 'toVtx', obj)\n\t\tself.next_loop_vtx = filter (lambda i: i not in startVtx, vtx)\n\t\tself.next_loop = self.ComponentInfo(self.next_loop_vtx, 'vtx', 'toContainedEdges', obj)\n\t\trings.append (self.next_loop)\n\t\tface_done.extend(startFaceAll)\n\t\tif sorted(self.next_loop)!= sorted(end):\n\t\t\tself.RingByRing (self.next_loop, end, rings, face_done, obj)\n\n\tdef CentralPosition (self, index, componentType, obj):\n\t\t# componentType - vtx, face, edge, uv\n\t\tmeshFn = Newom.MFnMesh(obj)\n\t\tverts = self.ComponentInfo(index, componentType, 'toVtx', obj)\n\t\tn = len(verts)\n\t\tvertsPos = []\n\t\tfor v in verts:\n\t\t\tvertsPos.append (meshFn.getPoint(v, Newom.MSpace.kWorld))\n\t\treturn map(lambda x: x/n, map(sum, zip(*vertsPos)))\n\n\tdef DeleteReplayFromList(self, lst):\n\t\tnewList=[]\n\t\tfor l in lst:\n\t\t\tif l not in newList:\n\t\t\t\tnewList.append(l)\n\t\treturn newList\n\n\tdef ComponentInfo (self, index, componentType, command, obj):\n\t\t# comand - toEdge, toFace, toVtx, toContainedEdges, toEdgePerimeter, length\n\t\t# componentType - vtx, face, edge, uv\n\t\tindexError = 'Error: Incorrect input ID component!!!'\n\t\tobjError = 'Error: Incorrect input obj!!!'\n\t\tobjGood = 0\n\t\ttry:\n\t\t\ttry:\n\t\t\t\tindex = list(set(index))\n\t\t\texcept TypeError:\n\t\t\t\tindex = [index,]\n\t\texcept:\n\t\t\treturn indexError\n\t\t\t\n\t\ttry:\n\t\t\tif obj.apiType() == 110 or obj.apiType() == 296:\n\t\t\t\tobjGood = 1\n\t\texcept:\n\t\t\treturn objError\n\t\tif objGood == 1:\n\t\t\tresult = []\n\t\t\titems = []\n\t\t\tmeshFn = Newom.MFnMesh(obj)\n\t\t\tif componentType == 'face':\n\t\t\t\tfaceIt = Newom.MItMeshPolygon(obj)\n\t\t\t\tif command == 'toEdgePerimeter':\n\t\t\t\t\tself.edges = self.ComponentInfo (index, 'face', 'toEdge', obj)\n\t\t\t\t\tedgeIt = Newom.MItMeshEdge(obj)\n\t\t\t\t\tfor self.edge in self.edges:\n\t\t\t\t\t\tface = self.ComponentInfo (self.edge, 'edge', 'toFace', obj)\n\t\t\t\t\t\tfor f in face:\n\t\t\t\t\t\t\tif f not in index:\n\t\t\t\t\t\t\t\titems.append(self.edge)\n\t\t\t\telif command == 'toFace':\n\t\t\t\t\tfor i in index:\n\t\t\t\t\t\tfaceIt.setIndex(i)\n\t\t\t\t\t\titems.extend(faceIt.getConnectedFaces())\n\t\t\t\telif command == 'toEdge':\n\t\t\t\t\tfor i in index:\n\t\t\t\t\t\tfaceIt.setIndex(i)\n\t\t\t\t\t\titems.extend(faceIt.getEdges())\n\t\t\t\telif command == 'toVtx':\n\t\t\t\t\tfor i in index:\n\t\t\t\t\t\tfaceIt.setIndex(i)\n\t\t\t\t\t\titems.extend(faceIt.getVertices())\n\t\t\t\t\t\t\n\t\t\telif componentType == 'edge':\n\t\t\t\tedgeIt = Newom.MItMeshEdge(obj)\n\t\t\t\tif command == 'toFace':\n\t\t\t\t\tfor i in index:\n\t\t\t\t\t\tedgeIt.setIndex(i)\n\t\t\t\t\t\titems.extend(edgeIt.getConnectedFaces())\n\t\t\t\telif command == 'length':\n\t\t\t\t\tlength = 0\n\t\t\t\t\tfor i in index:\n\t\t\t\t\t\tedgeIt.setIndex(i)\n\t\t\t\t\t\tlength += edgeIt.length(Newom.MSpace.kWorld)\n\t\t\t\t\treturn length\n\t\t\t\telif command == 'toEdge':\n\t\t\t\t\tfor i in index:\n\t\t\t\t\t\tedgeIt.setIndex(i)\n\t\t\t\t\t\titems.extend(edgeIt.getConnectedEdges())\n\t\t\t\telif command == 'toVtx':\n\t\t\t\t\tfor i in index:\n\t\t\t\t\t\tedgeIt.setIndex(i)\n\t\t\t\t\t\titems.append(edgeIt.vertexId(0))\n\t\t\t\t\t\titems.append(edgeIt.vertexId(1))\n\t\t\t\telif command == 'toEdgePerimeter':\n\t\t\t\t\tself.faces = self.ComponentInfo(index, 'edge', 'toFace', obj)\n\t\t\t\t\titems.extend(self.ComponentInfo(self.faces, 'face', 'toEdgePerimeter', obj))\n\t\t\telif componentType == 'vtx':\n\t\t\t\tvtxIt = Newom.MItMeshVertex(obj)\n\t\t\t\tfor i in index:\n\t\t\t\t\tvtxIt.setIndex(i)\n\t\t\t\tif command == 'toContainedEdges':\n\t\t\t\t\tfor i in index:\n\t\t\t\t\t\tvtxIt.setIndex(i)\n\t\t\t\t\t\tself.edges = vtxIt.getConnectedEdges()\n\t\t\t\t\t\tedgesIt = Newom.MItMeshEdge(obj)\n\t\t\t\t\t\tfor self.edge in self.edges:\n\t\t\t\t\t\t\tedgesIt.setIndex(self.edge)\n\t\t\t\t\t\t\tedgeVtx0 = edgesIt.vertexId(0)\n\t\t\t\t\t\t\tedgeVtx1 = edgesIt.vertexId(1)\n\t\t\t\t\t\t\tif edgeVtx0 in index and edgeVtx1 in index:\n\t\t\t\t\t\t\t\titems.append(self.edge)\n\t\t\t\telif command == 'toFace':\n\t\t\t\t\tfor i in index:\n\t\t\t\t\t\tvtxIt.setIndex(i)\n\t\t\t\t\t\titems.extend(vtxIt.getConnectedFaces())\n\t\t\t\telif command == 'toEdge':\n\t\t\t\t\tfor i in index:\n\t\t\t\t\t\tvtxIt.setIndex(i)\n\t\t\t\t\t\titems.extend(vtxIt.getConnectedEdges())\n\t\t\t\telif command == 'toVtx':\n\t\t\t\t\tfor i in index:\n\t\t\t\t\t\tvtxIt.setIndex(i)\n\t\t\t\t\t\titems.extend(vtxIt.getConnectedVertices())\n\t\t\titems = list(set(items))\n\t\t\tresult.extend(items)\n\t\t\treturn result\n\t\t\t\n\tdef getBorderEdges(self, obj):\n\t\tself.edges = Newom.MItMeshEdge(obj)\n\t\tindex = []\n\t\twhile not self.edges.isDone():\n\t\t\tif self.edges.onBoundary():\n\t\t\t\tindex.append(self.edges.index())\n\t\t\tself.edges.next()\n\t\treturn index\n\t\t\n\tdef getVertexStars (self, obj, star, mode = 'notBorder'):\n\t\tvtx = Newom.MItMeshVertex(obj)\n\t\tindex = []\n\t\twhile not vtx.isDone():\n\t\t\tn = vtx.numConnectedEdges()\n\t\t\tif star == 5:\n\t\t\t\tif n > 4:\n\t\t\t\t\tif mode == 'Border':\n\t\t\t\t\t\tindex.append(vtx.index())\n\t\t\t\t\telif mode == 'notBorder':\n\t\t\t\t\t\tif not vtx.onBoundary():\n\t\t\t\t\t\t\tindex.append(vtx.index())\n\t\t\telif star == 3:\n\t\t\t\tif n == 3:\n\t\t\t\t\tif not vtx.onBoundary():\n\t\t\t\t\t\tindex.append(vtx.index())\n\t\t\t\tif mode == 'Border':\n\t\t\t\t\tif n == 2:\n\t\t\t\t\t\tindex.append(vtx.index())\n\t\t\telif star == 2:\n\t\t\t\tif n == 2:\n\t\t\t\t\tif mode == 'Border':\n\t\t\t\t\t\tif vtx.onBoundary():\n\t\t\t\t\t\t\tindex.append(vtx.index())\n\t\t\t\t\telse:\n\t\t\t\t\t\tif not vtx.onBoundary():\n\t\t\t\t\t\t\tindex.append(vtx.index())\n\t\t\tvtx.next()\n\t\treturn index\n\t\t\n\tdef checkMesh (self, obj):\n\t\tfaceIt = Newom.MItMeshPolygon(obj)\n\t\twhile not faceIt.isDone():\n\t\t\tif faceIt.polygonVertexCount() > 4:\n\t\t\t\treturn 1\n\t\t\telif faceIt.isLamina():\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\tif vers == 2020:\n\t\t\t\t\tfaceIt.next()\n\t\t\t\telse:\n\t\t\t\t\tfaceIt.next(None)\n\t\tvtxIt = Newom.MItMeshVertex(obj)\n\t\twhile not vtxIt.isDone():\n\t\t\tif vtxIt.numConnectedEdges() == 0 or vtxIt.numConnectedEdges() == 1:\n\t\t\t\treturn 1\n\t\t\tvtxIt.next()\n\t\tedgeIt = Newom.MItMeshEdge(obj)\n\t\twhile not edgeIt.isDone():\n\t\t\tif edgeIt.numConnectedFaces() > 2:\n\t\t\t\treturn 1\n\t\t\tedgeIt.next()\n\t\treturn 0\n\n\tdef MeshInGroup (self, grp, result, vis=0):\n\t\tname = grp.longName()\n\t\tnameSplit = name.split('|')\n\t\tn = len(nameSplit)\n\t\tmesh = filter (lambda i: i.intermediateObject.get() == 0, ls (typ = 'mesh'))\n\t\tif mesh and vis == 1:\n\t\t\tmesh = ls(mesh, v=1, fl=1)\n\t\tfor m in mesh:\n\t\t\tpath = m.longName()\n\t\t\tpathSplit = path.split ('|')\n\t\t\tif len(pathSplit) > n:\n\t\t\t\tj=0\n\t\t\t\tfor i in range(n):\n\t\t\t\t\tif nameSplit[i] == pathSplit[i]:\n\t\t\t\t\t\tj += 1\n\t\t\t\tif j == n:\n\t\t\t\t\tresult.append(m.getParent())\n\ntry:\n\tCFT.close()\nexcept:\n\tpass\n\nmaya = getMayaWindow()\nCFT = CurveFromTubes(maya)\nCFT.show()" 
        -sourceType "python" 
        -commandRepeatable 1
        -flat 1
    ;

} 
